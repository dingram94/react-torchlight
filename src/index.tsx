import React, {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";
import { SpotlightOverlay } from "./components/spotlight-overlay";

// Import generated types (will be created by the plugin)
// The file will be generated by the TypeScript plugin when tours are defined
declare global {
  interface SpotlightToursRegistry {}
}

// Fallback types when generated file doesn't exist yet
type TOUR_IDS = Record<string, string>;
type TourId = string;
import {
  SpotlightContextProps,
  SpotlightProviderProps,
  SpotlightStep,
  SpotlightTour,
} from "./types";

// Re-export the generated types for convenience
export type { TOUR_IDS, TourId };

// Re-export types from types.ts
export type {
  SpotlightContextProps,
  SpotlightProviderProps,
  SpotlightStep,
  SpotlightTour,
} from "./types";

// Helper type to get registered tour IDs
type RegisteredTourIds = keyof SpotlightToursRegistry extends never
  ? string
  : keyof SpotlightToursRegistry;

export const SpotlightContext =
  createContext<SpotlightContextProps<RegisteredTourIds> | null>(null);

export const SpotlightProvider: React.FC<SpotlightProviderProps> = ({
  children,
  overlayProps = {},
}) => {
  const [tours, setTours] = useState<Map<string, SpotlightTour>>(new Map());
  const [activeTour, setActiveTour] = useState<RegisteredTourIds | null>(null);

  const registerStep = useCallback(
    (step: Omit<SpotlightStep, "target">, ref: React.RefObject<any>) => {
      setTours((prev) => {
        const newTours = new Map(prev);
        const tour = newTours.get(step.tourId) || {
          id: step.tourId,
          steps: [],
          currentStepIndex: 0,
          isActive: false,
        };

        const existingStepIndex = tour.steps.findIndex((s) => s.id === step.id);
        const newStep = { ...step, target: ref };

        if (existingStepIndex !== -1) {
          const existingStep = tour.steps[existingStepIndex];
          const isIdentical =
            existingStep.order === newStep.order &&
            existingStep.title === newStep.title &&
            existingStep.content === newStep.content &&
            existingStep.placement === newStep.placement &&
            existingStep.target === newStep.target;

          if (isIdentical) {
            return prev;
          }

          const updatedSteps = [...tour.steps];
          updatedSteps[existingStepIndex] = newStep;
          updatedSteps.sort((a, b) => a.order - b.order);

          newTours.set(step.tourId, {
            ...tour,
            steps: updatedSteps,
          });
        } else {
          const newSteps = [...tour.steps, newStep].sort(
            (a, b) => a.order - b.order
          );
          newTours.set(step.tourId, {
            ...tour,
            steps: newSteps,
          });
        }

        return newTours;
      });
    },
    []
  );

  const unregisterStep = useCallback(
    (stepId: string, tourId: RegisteredTourIds) => {
      setTours((prev) => {
        const newTours = new Map(prev);
        const tour = newTours.get(tourId as string);

        if (!tour) return prev;

        const newSteps = tour.steps.filter((s) => s.id !== stepId);

        if (newSteps.length === 0) {
          newTours.delete(tourId as string);
          if (activeTour === tourId) {
            setActiveTour(null);
          }
        } else {
          newTours.set(tourId as string, {
            ...tour,
            steps: newSteps,
            currentStepIndex: Math.min(
              tour.currentStepIndex,
              newSteps.length - 1
            ),
          });
        }

        return newTours;
      });
    },
    [activeTour]
  );

  const startTour = useCallback((tourId: RegisteredTourIds) => {
    setTours((prev) => {
      const newTours = new Map(prev);
      const tour = newTours.get(tourId as string);

      if (!tour) {
        console.warn(
          `Tour "${String(
            tourId
          )}" not found. Make sure all steps are registered.`
        );
        return prev;
      }

      if (tour.steps.length === 0) {
        console.warn(
          `Tour "${String(
            tourId
          )}" has no steps. Make sure components with steps are mounted.`
        );
        return prev;
      }

      newTours.set(tourId as string, {
        ...tour,
        isActive: true,
        currentStepIndex: 0,
      });

      return newTours;
    });

    setActiveTour(tourId);
  }, []);

  const stopTour = useCallback(
    (tourId: RegisteredTourIds) => {
      setTours((prev) => {
        const newTours = new Map(prev);
        const tour = newTours.get(tourId as string);

        if (tour) {
          newTours.set(tourId as string, {
            ...tour,
            isActive: false,
          });
        }

        return newTours;
      });

      if (activeTour === tourId) {
        setActiveTour(null);
      }
    },
    [activeTour]
  );

  const nextStep = useCallback((tourId: RegisteredTourIds) => {
    setTours((prev) => {
      const newTours = new Map(prev);
      const tour = newTours.get(tourId as string);

      if (!tour) return prev;

      if (tour.currentStepIndex < tour.steps.length - 1) {
        newTours.set(tourId as string, {
          ...tour,
          currentStepIndex: tour.currentStepIndex + 1,
        });
      } else {
        newTours.set(tourId as string, {
          ...tour,
          isActive: false,
        });
        setActiveTour(null);
      }

      return newTours;
    });
  }, []);

  const prevStep = useCallback((tourId: RegisteredTourIds) => {
    setTours((prev) => {
      const newTours = new Map(prev);
      const tour = newTours.get(tourId as string);

      if (tour && tour.currentStepIndex > 0) {
        newTours.set(tourId as string, {
          ...tour,
          currentStepIndex: tour.currentStepIndex - 1,
        });
      }

      return newTours;
    });
  }, []);

  const goToStep = useCallback(
    (tourId: RegisteredTourIds, stepIndex: number) => {
      setTours((prev) => {
        const newTours = new Map(prev);
        const tour = newTours.get(tourId as string);

        if (tour && stepIndex >= 0 && stepIndex < tour.steps.length) {
          newTours.set(tourId as string, {
            ...tour,
            currentStepIndex: stepIndex,
          });
        }

        return newTours;
      });
    },
    []
  );

  const contextValue = useMemo(
    () => ({
      tours,
      registerStep,
      unregisterStep,
      startTour,
      stopTour,
      nextStep,
      prevStep,
      goToStep,
      activeTour,
    }),
    [
      tours,
      registerStep,
      unregisterStep,
      startTour,
      stopTour,
      nextStep,
      prevStep,
      goToStep,
      activeTour,
    ]
  );

  return (
    <SpotlightContext.Provider value={contextValue}>
      {children}
      <SpotlightOverlay {...overlayProps} />
    </SpotlightContext.Provider>
  );
};

export const useSpotlight = () => {
  const context = useContext(SpotlightContext);

  if (!context) {
    throw new Error("useSpotlight must be used within a SpotlightProvider");
  }

  return context;
};

// Type-safe hook that registers tours and provides IntelliSense
export const useSpotlightSteps = <
  TourId extends keyof SpotlightToursRegistry,
  T extends string
>(
  tourId: TourId,
  steps: Omit<SpotlightStep<T>, "target" | "tourId">[]
) => {
  const { registerStep, unregisterStep } = useSpotlight();

  const refsRef = useRef<Record<T, React.RefObject<any>>>(
    {} as Record<T, React.RefObject<any>>
  );

  steps.forEach((step) => {
    if (!refsRef.current[step.id]) {
      refsRef.current[step.id] = { current: null };
    }
  });

  const currentStepsRef = useRef<string>("");
  const registeredStepsRef = useRef<Set<string>>(new Set());

  useEffect(() => {
    const stepsSignature = steps
      .map((s) => `${s.id}:${s.order}:${s.title || ""}:${s.placement || ""}`)
      .sort()
      .join("|");

    if (currentStepsRef.current !== stepsSignature) {
      steps.forEach((step) => {
        registerStep(
          {
            id: step.id,
            tourId: tourId as string,
            order: step.order,
            title: step.title,
            content: step.content,
            placement: step.placement || "bottom",
          },
          refsRef.current[step.id]
        );
        registeredStepsRef.current.add(step.id);
      });

      currentStepsRef.current = stepsSignature;
    }

    return () => {
      registeredStepsRef.current.forEach((stepId) => {
        unregisterStep(stepId, tourId);
      });
      registeredStepsRef.current.clear();
    };
  }, [tourId, registerStep, unregisterStep, steps]);

  useEffect(() => {
    steps.forEach((step) => {
      registerStep(
        {
          id: step.id,
          tourId: tourId as string,
          order: step.order,
          title: step.title,
          content: step.content,
          placement: step.placement || "bottom",
        },
        refsRef.current[step.id]
      );
    });
  }, [steps.map((s) => s.content || "").join(""), tourId, registerStep]);

  return refsRef.current;
};

// Helper function to define tours (provides better IntelliSense)
export const defineTours = <T extends Record<string, any>>(tours: T): T =>
  tours;

// Re-export components
export { SpotlightOverlay } from "./components/spotlight-overlay";

// Re-export plugins
export { default as createTypeScriptPlugin } from "./plugins/typescript-plugin";
export { createTransformer as createTypeScriptTransformer } from "./plugins/typescript-plugin";
export { vitePluginTours as createVitePlugin } from "./plugins/vite-plugin";
