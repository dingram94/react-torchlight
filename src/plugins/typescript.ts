import * as fs from "fs";
import * as path from "path";
import * as ts from "typescript";

interface PluginConfig {
  outputPath?: string;
  rootFolder?: string;
}

export default function createPlugin(
  info: ts.server.PluginCreateInfo
): ts.LanguageService {
  const config: PluginConfig = info.config || {};
  const { rootFolder = "src", outputPath = "torchlight.gen.ts" } = config;

  const tourIds = new Set<string>();
  let lastGeneratedContent = "";

  function extractTourIds(sourceFile: ts.SourceFile) {
    function visit(node: ts.Node) {
      // Look for useTorchlightSteps calls
      if (ts.isCallExpression(node)) {
        const expression = node.expression;

        // Handle direct calls: useTorchlightSteps("tourId", ...)
        if (
          ts.isIdentifier(expression) &&
          expression.text === "useTorchlightSteps"
        ) {
          const firstArg = node.arguments[0];
          if (
            ts.isStringLiteral(firstArg) &&
            firstArg.text.trim() !== "" &&
            firstArg.text !== "tourId"
          ) {
            tourIds.add(firstArg.text);
          }
        }

        // Handle property access: torchlight.useTorchlightSteps("tourId", ...)
        if (
          ts.isPropertyAccessExpression(expression) &&
          ts.isIdentifier(expression.name) &&
          expression.name.text === "useTorchlightSteps"
        ) {
          const firstArg = node.arguments[0];
          if (ts.isStringLiteral(firstArg) && firstArg.text.trim() !== "") {
            tourIds.add(firstArg.text);
          }
        }

        // Handle imported useTorchlightSteps calls
        if (ts.isCallExpression(node) && node.arguments.length >= 1) {
          const firstArg = node.arguments[0];
          if (ts.isStringLiteral(firstArg) && firstArg.text.trim() !== "") {
            // Check if this is likely a useTorchlightSteps call by looking at the expression
            const expressionText = node.expression.getText();
            if (expressionText.includes("useTorchlightSteps")) {
              tourIds.add(firstArg.text);
            }
          }
        }
      }

      ts.forEachChild(node, visit);
    }

    visit(sourceFile);
  }

  function generateTypeFile() {
    const sortedTourIds = Array.from(tourIds).sort();

    if (sortedTourIds.length === 0) {
      return; // Don't generate empty files
    }

    const content = `/* eslint-disable */

      // @ts-nocheck

      // noinspection JSUnusedGlobalSymbols
      
      // Auto-generated by torchlight-typescript-plugin
// Do not edit this file manually
// Generated on: ${new Date().toISOString()}

declare module "ReactTorchlight" {
  interface SpotlightToursRegistry {
${sortedTourIds.map((id) => `    '${id}': never;`).join("\n")}
  }
}

// Export the tour IDs for runtime use
export const TOUR_IDS = {
${sortedTourIds
  .map((id) => `  ${id.replace(/[^a-zA-Z0-9_]/g, "_")}: '${id}'`)
  .join(",\n")}
} as const;

export type TourId = ${sortedTourIds.map((id) => `'${id}'`).join(" | ")};

export {};
`;

    // Only write if content changed
    if (content !== lastGeneratedContent) {
      const outputDir = path.join(rootFolder, path.dirname(outputPath));
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }

      fs.writeFileSync(outputPath, content, "utf-8");
      lastGeneratedContent = content;

      console.log(
        `✅ Generated torchlight types with ${
          tourIds.size
        } tours: ${sortedTourIds.join(", ")}`
      );
    }
  }

  // Wrap the original language service
  const proxy = { ...info.languageService } as ts.LanguageService;

  // Override getSemanticDiagnostics to trigger our analysis
  proxy.getSemanticDiagnostics = (fileName: string) => {
    const diagnostics = info.languageService.getSemanticDiagnostics(fileName);

    // Only process TypeScript/TSX files
    if (fileName.endsWith(".ts") || fileName.endsWith(".tsx")) {
      const sourceFile = info.languageService
        .getProgram()
        ?.getSourceFile(fileName);
      if (sourceFile) {
        extractTourIds(sourceFile);
        generateTypeFile();
      }
    }

    return diagnostics;
  };

  return proxy;
}

// For use as a transformer
export function createTransformer(
  program: ts.Program,
  config: PluginConfig = {}
): ts.TransformerFactory<ts.SourceFile> {
  const outputPath = config.outputPath || "torchlight.gen.ts";
  const rootFolder = config.rootFolder || "src";
  const tourIds = new Set<string>();

  return (context: ts.TransformationContext) => {
    return (sourceFile: ts.SourceFile) => {
      function visit(node: ts.Node): ts.Node {
        if (ts.isCallExpression(node)) {
          const expression = node.expression;

          // Handle useTorchlightSteps calls
          if (
            ts.isIdentifier(expression) &&
            expression.text === "useTorchlightSteps"
          ) {
            const firstArg = node.arguments[0];
            if (ts.isStringLiteral(firstArg) && firstArg.text.trim() !== "") {
              tourIds.add(firstArg.text);
            }
          }
        }

        return ts.visitEachChild(node, visit, context);
      }

      const result = ts.visitNode(sourceFile, visit) as ts.SourceFile;

      // Generate types after processing all files
      if (tourIds.size > 0) {
        const sortedTourIds = Array.from(tourIds).sort();
        const content = `/* eslint-disable */

      // @ts-nocheck

      // noinspection JSUnusedGlobalSymbols
      
      // Auto-generated by torchlight-typescript-plugin
// Do not edit this file manually
// Generated on: ${new Date().toISOString()}

declare module "ReactTorchlight" {
  interface SpotlightToursRegistry {
${sortedTourIds.map((id) => `    '${id}': never;`).join("\n")}
  }
}

// Export the tour IDs for runtime use
export const TOUR_IDS = {
${sortedTourIds
  .map((id) => `  ${id.replace(/[^a-zA-Z0-9_]/g, "_")}: '${id}'`)
  .join(",\n")}
} as const;

export type TourId = ${sortedTourIds.map((id) => `'${id}'`).join(" | ")};

export {};
`;

        const outputDir = path.join(rootFolder, path.dirname(outputPath));
        if (!fs.existsSync(outputDir)) {
          fs.mkdirSync(outputDir, { recursive: true });
        }

        fs.writeFileSync(outputPath, content, "utf-8");
        console.log(
          `✅ Generated torchlight types with ${
            tourIds.size
          } tours: ${sortedTourIds.join(", ")}`
        );
      }

      return result;
    };
  };
}
