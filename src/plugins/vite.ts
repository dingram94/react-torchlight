import * as fs from "fs";
import * as path from "path";
import { Plugin } from "vite";

interface TorchlightVitePluginOptions {
  rootFolder?: string;
  outputPath?: string;
}

export function torchlightVitePlugin(
  options: TorchlightVitePluginOptions = {}
): Plugin {
  const { rootFolder = "src", outputPath = "torchlight.gen.ts" } = options;

  let config: any;
  const tourIds = new Set<string>();
  let isDevMode = false;

  // Function to generate the types file
  const generateTypesFile = () => {
    const sortedTourIds = Array.from(tourIds).sort();

    if (sortedTourIds.length === 0) {
      console.log(
        "âš ï¸ No tour IDs found. Make sure you have useTorchlightSteps calls in your code."
      );
      return;
    }

    const content = `
/* eslint-disable */
// @ts-nocheck
// noinspection JSUnusedGlobalSymbols

// Auto-generated by torchlight-vite-plugin
// Do not edit this file manually
// Generated on: ${new Date().toISOString()}

declare module "react-torchlight" {
  interface TorchlightToursRegistry {
${sortedTourIds.map((id) => `    "${id}": "${id}";`).join("\n")}
  }
}

// Export the tour IDs for runtime use
export const TOUR_IDS = {
${sortedTourIds
  .map(
    (id, index) =>
      `  ${id.replace(/[^a-zA-Z0-9_]/g, "_")}: "${id}"${
        index < sortedTourIds.length - 1 ? "," : ""
      }`
  )
  .join("\n")}
} as const;

export type TourId = ${sortedTourIds.map((id) => `"${id}"`).join(" | ")};
`;

    // Create the full output path
    const fullOutputPath = path.resolve(rootFolder, outputPath);
    const outputDir = path.dirname(fullOutputPath);

    console.log(`ðŸ“ Creating directory: ${outputDir}`);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    console.log(`ðŸ“ Writing file: ${fullOutputPath}`);
    fs.writeFileSync(fullOutputPath, content, "utf-8");
    console.log(
      `âœ… Generated torchlight types with ${
        tourIds.size
      } tours: ${sortedTourIds.join(", ")}`
    );
  };

  return {
    name: "torchlight-vite-plugin",
    configResolved(resolvedConfig) {
      config = resolvedConfig;
      isDevMode = resolvedConfig.command === "serve";
      console.log(
        `ðŸ”§ Torchlight Vite Plugin initialized with rootFolder: ${rootFolder}, outputPath: ${outputPath}, mode: ${
          isDevMode ? "dev" : "build"
        }`
      );
    },
    configureServer(server) {
      // This runs in dev mode and sets up file watching
      console.log("ðŸš€ Setting up dev server with hot reload support");

      // Watch for file changes and regenerate types
      server.watcher.on("change", (file) => {
        if (file.endsWith(".ts") || file.endsWith(".tsx")) {
          console.log(`ðŸ”„ File changed: ${file}, regenerating types...`);
          // Clear the tour IDs and re-scan
          tourIds.clear();
          // The transform hook will be called again for all files
          setTimeout(() => {
            generateTypesFile();
          }, 100); // Small delay to ensure all files are processed
        }
      });

      // Initial generation
      setTimeout(() => {
        generateTypesFile();
      }, 500);
    },
    transform(code, id) {
      // Only process TypeScript/TSX files
      if (!id.endsWith(".ts") && !id.endsWith(".tsx")) {
        return null;
      }

      // Skip the generated file itself
      if (id.includes("torchlight.gen.ts")) {
        return null;
      }

      // Simple regex-based extraction for tour IDs
      // This is a simplified version - the TypeScript plugin provides more robust parsing
      const useTorchlightStepsRegex =
        /useTorchlightSteps\s*\(\s*["']([^"']+)["']/g;

      let match;
      while ((match = useTorchlightStepsRegex.exec(code)) !== null) {
        const tourId = match[1];
        if (tourId && tourId.trim() !== "" && tourId !== "tourId") {
          tourIds.add(tourId);
          console.log(`ðŸŽ¯ Found tour ID: ${tourId} in ${id}`);
        }
      }

      return null;
    },
    generateBundle() {
      // This runs during build mode
      if (!isDevMode) {
        generateTypesFile();
      }
    },
    closeBundle() {
      // This runs after the bundle is closed, which happens in both dev and build
      if (!isDevMode) {
        generateTypesFile();
      }
    },
  };
}
