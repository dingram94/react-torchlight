'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fs = require('fs');
var path = require('path');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var fs__namespace = /*#__PURE__*/_interopNamespace(fs);
var path__namespace = /*#__PURE__*/_interopNamespace(path);

function torchlightVitePlugin(options = {}) {
    const { rootFolder = "src", outputPath = "torchlight.gen.ts" } = options;
    const tourIds = new Set();
    return {
        name: "torchlight-vite-plugin",
        configResolved(resolvedConfig) {
        },
        transform(code, id) {
            // Only process TypeScript/TSX files
            if (!id.endsWith(".ts") && !id.endsWith(".tsx")) {
                return null;
            }
            // Skip the generated file itself
            if (id.includes("torchlight.gen.ts")) {
                return null;
            }
            // Simple regex-based extraction for tour IDs
            // This is a simplified version - the TypeScript plugin provides more robust parsing
            const useTorchlightStepsRegex = /useTorchlightSteps\s*\(\s*["']([^"']+)["']/g;
            const defineToursRegex = /defineTours\s*\(\s*\{([^}]+)\}/g;
            let match;
            while ((match = useTorchlightStepsRegex.exec(code)) !== null) {
                const tourId = match[1];
                if (tourId && tourId.trim() !== "" && tourId !== "tourId") {
                    tourIds.add(tourId);
                }
            }
            // Extract from defineTours calls
            while ((match = defineToursRegex.exec(code)) !== null) {
                const tourObject = match[1];
                const propertyRegex = /(\w+)\s*:/g;
                let propMatch;
                while ((propMatch = propertyRegex.exec(tourObject)) !== null) {
                    tourIds.add(propMatch[1]);
                }
            }
            return null;
        },
        generateBundle() {
            const sortedTourIds = Array.from(tourIds).sort();
            if (sortedTourIds.length === 0) {
                return;
            }
            const content = `
      /* eslint-disable */

      // @ts-nocheck

      // noinspection JSUnusedGlobalSymbols
      
      // Auto-generated by torchlight-vite-plugin
// Do not edit this file manually
// Generated on: ${new Date().toISOString()}

declare module "ReactTorchlight" {
  interface SpotlightToursRegistry {
${sortedTourIds.map((id) => `    "${id}": never;`).join("\n")}
  }
}

// Export the tour IDs for runtime use
export const TOUR_IDS = {
${sortedTourIds
                .map((id, index) => `  ${id.replace(/[^a-zA-Z0-9_]/g, "_")}: "${id}"${index < sortedTourIds.length - 1 ? "," : ""}`)
                .join("\n")}
} as const;

export type TourId = ${sortedTourIds.map((id) => `"${id}"`).join(" | ")};
`;
            const outputDir = path__namespace.join(rootFolder, path__namespace.dirname(outputPath));
            if (!fs__namespace.existsSync(outputDir)) {
                fs__namespace.mkdirSync(outputDir, { recursive: true });
            }
            fs__namespace.writeFileSync(outputPath, content, "utf-8");
            console.log(`âœ… Generated torchlight types with ${tourIds.size} tours: ${sortedTourIds.join(", ")}`);
        },
    };
}

exports.torchlightVitePlugin = torchlightVitePlugin;
//# sourceMappingURL=vite.js.map
