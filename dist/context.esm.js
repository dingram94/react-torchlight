import{jsx as e}from"react/jsx-runtime";import{createContext as t,useState as r,useCallback as n,useMemo as o,useContext as s,useRef as c,useEffect as u}from"react";const i=t(null),p=({children:t,overlayProps:s={}})=>{const[c,u]=r(new Map),[p,d]=r(null),l=n((e,t)=>{u(r=>{const n=new Map(r),o=n.get(e.tourId)||{id:e.tourId,steps:[],currentStepIndex:0,isActive:!1},s=o.steps.findIndex(t=>t.id===e.id),c={...e,target:t};if(-1!==s){const t=o.steps[s];if(t.order===c.order&&t.title===c.title&&t.content===c.content&&t.placement===c.placement&&t.target===c.target)return r;const u=[...o.steps];u[s]=c,u.sort((e,t)=>e.order-t.order),n.set(e.tourId,{...o,steps:u})}else{const t=[...o.steps,c].sort((e,t)=>e.order-t.order);n.set(e.tourId,{...o,steps:t})}return n})},[]),a=n((e,t)=>{u(r=>{const n=new Map(r),o=n.get(t);if(!o)return r;const s=o.steps.filter(t=>t.id!==e);return 0===s.length?(n.delete(t),p===t&&d(null)):n.set(t,{...o,steps:s,currentStepIndex:Math.min(o.currentStepIndex,s.length-1)}),n})},[p]),g=n(e=>{u(t=>{const r=new Map(t),n=r.get(e);return n?0===n.steps.length?(console.warn(`Tour "${String(e)}" has no steps. Make sure components with steps are mounted.`),t):(r.set(e,{...n,isActive:!0,currentStepIndex:0}),r):(console.warn(`Tour "${String(e)}" not found. Make sure all steps are registered.`),t)}),d(e)},[]),S=n(e=>{u(t=>{const r=new Map(t),n=r.get(e);return n&&r.set(e,{...n,isActive:!1}),r}),p===e&&d(null)},[p]),h=n(e=>{u(t=>{const r=new Map(t),n=r.get(e);return n?(n.currentStepIndex<n.steps.length-1?r.set(e,{...n,currentStepIndex:n.currentStepIndex+1}):(r.set(e,{...n,isActive:!1}),d(null)),r):t})},[]),m=n(e=>{u(t=>{const r=new Map(t),n=r.get(e);return n&&n.currentStepIndex>0&&r.set(e,{...n,currentStepIndex:n.currentStepIndex-1}),r})},[]),I=n((e,t)=>{u(r=>{const n=new Map(r),o=n.get(e);return o&&t>=0&&t<o.steps.length&&n.set(e,{...o,currentStepIndex:t}),n})},[]),w=o(()=>({tours:c,registerStep:l,unregisterStep:a,startTour:g,stopTour:S,nextStep:h,prevStep:m,goToStep:I,activeTour:p}),[c,l,a,g,S,h,m,I,p]);return e(i.Provider,{value:w,children:t})},d=()=>{const e=s(i);if(!e)throw new Error("useTorchlight must be used within a TorchlightProvider");return e},l=(e,t)=>{const{registerStep:r,unregisterStep:n}=d(),o=c({});t.forEach(e=>{o.current[e.id]||(o.current[e.id]={current:null})});const s=c(""),i=c(new Set);return u(()=>{const c=t.map(e=>`${e.id}:${e.order}:${e.title||""}:${e.placement||""}`).sort().join("|");return s.current!==c&&(t.forEach(t=>{r({id:t.id,tourId:e,order:t.order,title:t.title,content:t.content,placement:t.placement||"bottom"},o.current[t.id]),i.current.add(t.id)}),s.current=c),()=>{i.current.forEach(t=>{n(t,e)}),i.current.clear()}},[e,r,n,t]),u(()=>{t.forEach(t=>{r({id:t.id,tourId:e,order:t.order,title:t.title,content:t.content,placement:t.placement||"bottom"},o.current[t.id])})},[t.map(e=>e.content||"").join(""),e,r]),o.current};export{i as TorchlightContext,p as TorchlightInternalProvider,d as useTorchlight,l as useTorchlightSteps};
//# sourceMappingURL=context.esm.js.map
